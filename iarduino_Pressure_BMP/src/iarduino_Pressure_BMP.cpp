#include "iarduino_Pressure_BMP.h"																					//
//			ФУНКЦИЯ ИНИЦИАЛИЗАЦИИ ДАТЧИКА:																			//
bool		iarduino_Pressure_BMP::begin(float i){																	//	Аргументы:	i - текущая высота
				objI2C->begin(100);																					//	Инициируем работу шины I2C с тактовой частотой 100 кГц
				valID=readBytes(BMPXXX_ADDRR_ID);																	//	Читаем ID модуля из регистра BMPXXX_ADDRR_ID
				if (valID==BMP180_ID){																				//	
					type=180;																						//	Сохраняем тип датчика
//	BMP180:			Читаем калибровочные коэффициенты:																//	Старший байт в младшем регистре
					BMP_16S[0] = ( int16_t) readBytes(BMP180_ADDRR_AC1, 2, false);									//	2 байтовая константа AC1 для корректировки температуры и давления
					BMP_16S[1] = ( int16_t) readBytes(BMP180_ADDRR_AC2, 2, false);									//	2 байтовая константа AC2 для корректировки температуры и давления
					BMP_16S[2] = ( int16_t) readBytes(BMP180_ADDRR_AC3, 2, false);									//	2 байтовая константа AC3 для корректировки температуры и давления
					BMP_16U[0] = (uint16_t) readBytes(BMP180_ADDRR_AC4, 2, false);									//	2 байтовая константа AC4 для корректировки температуры и давления (без знака)
					BMP_16U[1] = (uint16_t) readBytes(BMP180_ADDRR_AC5, 2, false);									//	2 байтовая константа AC5 для корректировки температуры и давления (без знака)
					BMP_16U[2] = (uint16_t) readBytes(BMP180_ADDRR_AC6, 2, false);									//	2 байтовая константа AC6 для корректировки температуры и давления (без знака)
					BMP_16S[3] = ( int16_t) readBytes(BMP180_ADDRR_B1 , 2, false);									//	2 байтовая константа B1  для корректировки температуры и давления
					BMP_16S[4] = ( int16_t) readBytes(BMP180_ADDRR_B2 , 2, false);									//	2 байтовая константа B2  для корректировки температуры и давления
					BMP_16S[5] = ( int16_t) readBytes(BMP180_ADDRR_MB , 2, false);									//	2 байтовая константа MB  для корректировки температуры и давления
					BMP_16S[6] = ( int16_t) readBytes(BMP180_ADDRR_MC , 2, false);									//	2 байтовая константа MC  для корректировки температуры и давления
					BMP_16S[7] = ( int16_t) readBytes(BMP180_ADDRR_MD , 2, false);									//	2 байтовая константа MD  для корректировки температуры и давления
				}else if(valID==BMP280_ID){																			//
					type=280;																						//	Сохраняем тип датчика
//	BMP280:			Читаем калибровочные коэффициенты:																//	Старший байт в старшем регистре
					BMP_16U[0] = (uint16_t) readBytes(BMP280_ADDRR_T1 , 2);											//	2 байтовая константа T1  для корректировки температуры и давления (без знака)
					BMP_16S[0] = ( int16_t) readBytes(BMP280_ADDRR_T2 , 2);											//	2 байтовая константа T2  для корректировки температуры и давления
					BMP_16S[1] = ( int16_t) readBytes(BMP280_ADDRR_T3 , 2);											//	2 байтовая константа T3  для корректировки температуры и давления
					BMP_16U[1] = (uint16_t) readBytes(BMP280_ADDRR_P1 , 2);											//	2 байтовая константа P1  для корректировки температуры и давления (без знака)
					BMP_16S[2] = ( int16_t) readBytes(BMP280_ADDRR_P2 , 2);											//	2 байтовая константа P2  для корректировки температуры и давления
					BMP_16S[3] = ( int16_t) readBytes(BMP280_ADDRR_P3 , 2);											//	2 байтовая константа P3  для корректировки температуры и давления
					BMP_16S[4] = ( int16_t) readBytes(BMP280_ADDRR_P4 , 2);											//	2 байтовая константа P4  для корректировки температуры и давления
					BMP_16S[5] = ( int16_t) readBytes(BMP280_ADDRR_P5 , 2);											//	2 байтовая константа P5  для корректировки температуры и давления
					BMP_16S[6] = ( int16_t) readBytes(BMP280_ADDRR_P6 , 2);											//	2 байтовая константа P6  для корректировки температуры и давления
					BMP_16S[7] = ( int16_t) readBytes(BMP280_ADDRR_P7 , 2);											//	2 байтовая константа P7  для корректировки температуры и давления
					BMP_16S[8] = ( int16_t) readBytes(BMP280_ADDRR_P8 , 2);											//	2 байтовая константа P8  для корректировки температуры и давления
					BMP_16S[9] = ( int16_t) readBytes(BMP280_ADDRR_P9 , 2);											//	2 байтовая константа P9  для корректировки температуры и давления
				}else{return false;}																				//	Если valID <> BMP180_ID и valID <> BMP280_ID значит устройство с адресом valAddress на шине I2C не является датчиком MBP, возвращаем false.
//					Считываем версию прошивки датчика:																//
					version    = (uint16_t) readBytes(BMPXXX_ADDRR_VERSION);										//
//					Устанавливаем точность:																			//
					if(!measurement(valMeasurement)){valID=0; return false;}										//	Если не удалось установить точность, то возвращаем false.
//					Рассчитываем давление на уровне моря (мм.рт.ст.):												//
					read(); delay(500); read();																		//	Инициируем чтение для получения текущего атмосферного давления
					valSeaLevelPressure	= pressure/pow(1-(i/44330),5.255);											//	Вычисляем давление на уровне моря, зная текущее атмосферное давление «pressure» и полученную высоту «i»
					return true;																					//	Если все шаги инициализации выполнены, то возвращаем true
}																													//
//			ФУНКЦИЯ УСТАНОВКИ ТОЧНОСТИ:																				//
bool		iarduino_Pressure_BMP::measurement(uint8_t i){															//	Аргументы: степень передискретизации (точность). Значение от 0-минимальная до 3 (для bmp180) или до 4 (для bmp280) включительно
/*	BMP180:	*/	if		(valID==BMP180_ID){	if(i>3){i=3;}															//	Корректируем значение передискретизации для датчика BMP180
/*	BMP280:	*/	}else if(valID==BMP280_ID){	if(i>4){i=4;}															//	Корректируем значение передискретизации для датчика BMP280
					if(!objI2C->writeByte(valAddress,BMPXXX_ADDRR_CTRL,((i+1)<<5|(i+1)<<2|0b11))){return false;}	//	Eсли не удалось записать байт данных ( OSRS_T[2:0] | OSRS_P[2:0] | MODE[1:0] ) в регистр BMPXXX_ADDRR_CTRL, то возвращаем false.
				}else{return false;}																				//	Если valID <> BMP180_ID и valID <> BMP280_ID значит устройство с адресом valAddress на шине I2C не является датчиком MBP, возвращаем false.
				valMeasurement=i; return true;																		//	Если все шаги установки передискретизации выполнены, то возвращаем true
}																													//
//			ФУНКЦИЯ ЧТЕНИЯ ВСЕХ ДАННЫХ СЕНСОРА:																		//
bool		iarduino_Pressure_BMP::read(uint8_t i){																	//	Аргументы: значение 1 или 2 (1 - получить давление в мм.рт.ст., 2 - получить давление в Па)
				if (valID==BMP180_ID){																				//
//	BMP180:			Читаем «сырые» значения температуры и давления из датчика:										//
					uint8_t j;																						//
					if(objI2C->writeByte(valAddress, BMPXXX_ADDRR_CTRL, 0x2E)){										//	Если в регистр BMPXXX_ADDRR_CTRL записалось значение 0x2E (инициализация расчёта температуры)
						j=50; while( bitRead(objI2C->readByte(valAddress, BMPXXX_ADDRR_CTRL),5) && j){j--;}			//	Ждём установки флага SCO (пятый бит байта) в регистре BMPXXX_ADDRR_CTRL (флаг SCO сигнализирует о завершении расчёта)
						BMP_TEMP = (int32_t) readBytes(BMP180_ADDRR_ALL, 2, false);									//	Получаем значение «сырой» температуры в виде 2 байт из регистра BMP180_ADDRR_ALL
					}else{return false;}																			//	Если в регистр BMPXXX_ADDRR_CTRL записать значение не удалось, то возвращаем false.
					if(objI2C->writeByte(valAddress, BMPXXX_ADDRR_CTRL, (0x34 | valMeasurement<<6) )){				//	Если в регистр BMPXXX_ADDRR_CTRL записалось значение 0x34 или 0x74 или 0xB4 или 0xF4 (инициализация расчёта давления с точностью valMeasurement)
						j=50; while( bitRead(objI2C->readByte(valAddress, BMPXXX_ADDRR_CTRL),5) && j){j--;}			//	Ждём установки флага SCO (пятый бит байта) в регистре BMPXXX_ADDRR_CTRL (флаг SCO сигнализирует о завершении расчёта)
						BMP_PRES = (int32_t) readBytes(BMP180_ADDRR_ALL, 3, false) >> (8-valMeasurement);			//	Получаем значение «сырого» давления в виде 3 байт из регистра BMP180_ADDRR_ALL
					}else{return false;}																			//	Если в регистр BMPXXX_ADDRR_CTRL записать значение не удалось, то возвращаем false.
//					Вычисляем промежуточные значения по формулам из datasheet:
					BMP_32S[0]	= ( (BMP_TEMP-BMP_16U[2]) * BMP_16U[1] >> 15 ) + ((int32_t)BMP_16S[6]<<11) / ( ( (BMP_TEMP-BMP_16U[2]) * BMP_16U[1] >> 15 ) + BMP_16S[7] );
					BMP_32U[0]	= ( (uint32_t) BMP_16U[0] * (uint32_t)(((( (BMP_16S[2] * (BMP_32S[0]-4000) ) >> 13 ) + (( BMP_16S[3] * (( (BMP_32S[0]-4000) * (BMP_32S[0]-4000) ) >> 12 )) >> 16 ) + 2 ) >> 2 ) + 32768 ) ) >> 15;
					BMP_32U[1]	= ( (uint32_t) BMP_PRES - (((( BMP_16S[0]*4 + (( BMP_16S[4] * (( (BMP_32S[0]-4000) * (BMP_32S[0]-4000) ) >> 12 )) >> 11 ) + (( BMP_16S[1] * (BMP_32S[0]-4000) ) >> 11 )) << valMeasurement ) + 2 ) >> 2 )) * (uint32_t)(50000UL >> valMeasurement);
					BMP_32S[1]	= BMP_32U[1]<0x80000000? BMP_32U[1]*2/BMP_32U[0] : BMP_32U[1]/BMP_32U[0]*2;
//					Вычисляем реальные значения по формулам из datasheet для температуры, давления и высоты:
					temperature	= ( (float)BMP_32S[0] + 8 ) / 160;
					pressure	= ( (float)BMP_32S[1] + (((( (BMP_32S[1]>>8) * (BMP_32S[1]>>8) * 3038 ) >> 16 ) + ( (-7357*BMP_32S[1]) >> 16 ) + 3791 ) >> 4 )); if(i==1){pressure /= 133.322;}
					altitude	= 44330 * ( 1 - pow( pressure / (i==1?1.00:133.322) / valSeaLevelPressure , 1/5.255 ));
				}else if(valID==BMP280_ID){																			//
//	BMP280:			Читаем «сырые» значения температуры и давления из датчика:										//
					BMP_TEMP	= readBytes(BMP280_ADDRR_TEMP, 3, false) >> 4;										//	Получаем значение «сырой» температуры в виде 3 байт из регистра BMP280_ADDRR_TEMP ( старший байт в младшем регистре, последние 4 бита не учитываются)
					BMP_PRES	= readBytes(BMP280_ADDRR_PRES, 3, false) >> 4;										//	Получаем значение «сырого» давления   в виде 3 байт из регистра BMP280_ADDRR_PRES ( старший байт в младшем регистре, последние 4 бита не учитываются)
//					Вычисляем промежуточные значения по формулам из datasheet:
					BMP_32S[0]	= ((( (BMP_TEMP>>3) - ( (int32_t)BMP_16U[0] << 1 ))) * ( (int32_t)BMP_16S[0] ) ) >> 11;
					BMP_32S[1]	= (((((BMP_TEMP>>4) - ( (int32_t)BMP_16U[0] ) ) * ( (BMP_TEMP>>4) - ( (int32_t)BMP_16U[0] ) )) >> 12) * ( (int32_t)BMP_16S[1] ) ) >> 14;
					BMP_64S[0]	= ( (int64_t)(BMP_32S[0] + BMP_32S[1]) ) - 128000;
					BMP_64S[1]	= ( BMP_64S[0] * BMP_64S[0] * (int64_t)BMP_16S[6] )        + (( BMP_64S[0] * (int64_t)BMP_16S[5] ) << 17 ) + (( (int64_t)BMP_16S[4] ) << 35 );
					BMP_64S[0]	= ((BMP_64S[0] * BMP_64S[0] * (int64_t)BMP_16S[3] ) >> 8 ) + (( BMP_64S[0] * (int64_t)BMP_16S[2] ) << 12 );
					BMP_64S[0]	= ((( (int64_t)1 ) << 47 ) + BMP_64S[0] ) * ( (int64_t)BMP_16U[1] ) >> 33; if(!BMP_64S[0]){BMP_64S[0]=1;}
					BMP_64S[2]	= ((( (int64_t)(1048576 - BMP_PRES) << 31 ) - BMP_64S[1] ) * 3125 ) / BMP_64S[0];
					BMP_64S[0]	= (( (int64_t)BMP_16S[9] ) * ( BMP_64S[2] >> 13 ) * ( BMP_64S[2] >> 13 ) ) >> 25;
					BMP_64S[1]	= (( (int64_t)BMP_16S[8] ) * BMP_64S[2] ) >> 19;
//					Вычисляем реальные значения по формулам из datasheet для температуры, давления и высоты:
					temperature	= (float)(( (BMP_32S[0] + BMP_32S[1]) * 5 + 128) >> 8 ) / 100;
					pressure	= (float)(( (BMP_64S[2] + BMP_64S[0] + BMP_64S[1]) >> 8) + (( (int64_t)BMP_16S[7] ) << 4 ) ) / 256; if(i==1){pressure /= 133.322;}
					altitude	= 44330 * ( 1 - pow( pressure / (i==1?1.00:133.322) / valSeaLevelPressure , 1/5.255 ));
				}else{return false;}																				//	Если valID <> BMP180_ID и valID <> BMP280_ID значит устройство с адресом valAddress на шине I2C не является датчиком MBP, возвращаем false.
				return true;																						//	Если все шаги вычислений выполнены, то возвращаем true
}																													//
																													//
//			ФУНКЦИЯ ЧТЕНИЯ ДАННЫХ ИЗ РЕГИСТРОВ ДАТЧИКА В ВИДЕ ЧИСЛА:												//
uint32_t	iarduino_Pressure_BMP::readBytes(uint8_t i, uint8_t j, bool f){											//	Объявляем функцию чтения регистров датчика						(аргументы: адрес_регистра, количество_байт, чем_старше_регистр_тем_старше_байт)
				uint32_t d=0;																						//	Определяем локальную переменную d для вывода прочитанных данных
				uint8_t  data[j];																					//	Объявляем массив data из j элементов
				objI2C->readBytes(valAddress, i, data, j);															//	Заполняем массив data читая j байт из модуля valAddress начиная с регистра i
				for(uint8_t k=0; k<j; k++){																			//	Заполняем переменную d в цикле из j шагов ...
					if(f){       d|=uint32_t(data[k])<<(k*8);}														//	Если флаг f установлен, то чем старше элемент массива data, тем старше позиция прочитанного байта в переменной d.
					else {d<<=8; d|=uint32_t(data[k])       ;}														//	Если флаг f сброшен,    то чем старше элемент массива data, тем младше позиция прочитанного байта в переменной d.
				}	return d;																						//	Возвращаем значение переменной d
}																													//