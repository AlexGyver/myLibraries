//	Библиотека для работы с датчиками атмосферного давления и температуры BMP180 и(или) BMP280. http://iarduino.ru/shop/Sensory-Datchiki/davleniya/
//  Версия: 1.1.0
//  Последнюю версию библиотеки Вы можете скачать по ссылке: http://iarduino.ru/file/227.html
//  Подробное описание функции бибилиотеки доступно по ссылке: http://wiki.iarduino.ru/page/trema-modul-pressure-meter
//  Библиотека является собственностью интернет магазина iarduino.ru и может свободно использоваться и распространяться!
//  При публикации устройств или скетчей с использованием данной библиотеки, как целиком, так и её частей,
//  в том числе и в некоммерческих целях, просим Вас опубликовать ссылку: http://iarduino.ru
//  Автор библиотеки: Панькин Павел sajaem@narod.ru
//  Если у Вас возникли технические вопросы, напишите нам: shop@iarduino.ru

#ifndef iarduino_Pressure_BMP_h													//
#define iarduino_Pressure_BMP_h													//
																				//
#if defined(ARDUINO) && (ARDUINO >= 100)										//
#include <Arduino.h>															//
#else																			//
#include <WProgram.h>															//
#endif																			//
																				//
#include <iarduino_Pressure_BMP_I2C.h>											//	Подключаем файл iarduino_Pressure_BMP_I2C.h - для работы с шиной I2C        (используя функции производного класса iarduino_I2C)
																				//
//		Идентификаторы чипов:													//
		#define BMP280_ID					0x58 // 0x58						//	Идентификатор чипа BMP280, содержится в регистре BMPXXX_ADDRR_ID.
		#define BMP180_ID					0x55 // 0x55						//	Идентификатор чипа BMP180, содержится в регистре BMPXXX_ADDRR_ID.
//		Адреса регистров содержащих калибровочные коэффициенты:					//
		#define BMP280_ADDRR_T1				0x88 // 0x88 - 0x89					//	Значение занимает 2 байта => использует 2 регистра.
		#define BMP280_ADDRR_T2				0x8A // 0x8A - 0x8B					//	Значение занимает 2 байта => использует 2 регистра.
		#define BMP280_ADDRR_T3				0x8C // 0x8C - 0x8D					//	Значение занимает 2 байта => использует 2 регистра.
		#define BMP280_ADDRR_P1				0x8E // 0x8E - 0x8F					//	Значение занимает 2 байта => использует 2 регистра.
		#define BMP280_ADDRR_P2				0x90 // 0x90 - 0x91					//	Значение занимает 2 байта => использует 2 регистра.
		#define BMP280_ADDRR_P3				0x92 // 0x92 - 0x93					//	Значение занимает 2 байта => использует 2 регистра.
		#define BMP280_ADDRR_P4				0x94 // 0x94 - 0x95					//	Значение занимает 2 байта => использует 2 регистра.
		#define BMP280_ADDRR_P5				0x96 // 0x96 - 0x97					//	Значение занимает 2 байта => использует 2 регистра.
		#define BMP280_ADDRR_P6				0x98 // 0x98 - 0x99					//	Значение занимает 2 байта => использует 2 регистра.
		#define BMP280_ADDRR_P7				0x9A // 0x9A - 0x9B					//	Значение занимает 2 байта => использует 2 регистра.
		#define BMP280_ADDRR_P8				0x9C // 0x9C - 0x9D					//	Значение занимает 2 байта => использует 2 регистра.
		#define BMP280_ADDRR_P9				0x9E // 0x9E - 0x9F					//	Значение занимает 2 байта => использует 2 регистра.
		#define BMP180_ADDRR_AC1			0xAA // 0xAA - 0xAB					//	Значение занимает 2 байта => использует 2 регистра.
		#define BMP180_ADDRR_AC2			0xAC // 0xAC - 0xAD					//	Значение занимает 2 байта => использует 2 регистра.
		#define BMP180_ADDRR_AC3			0xAE // 0xAE - 0xAF					//	Значение занимает 2 байта => использует 2 регистра.
		#define BMP180_ADDRR_AC4			0xB0 // 0xB0 - 0xB1					//	Значение занимает 2 байта => использует 2 регистра.
		#define BMP180_ADDRR_AC5			0xB2 // 0xB2 - 0xB3					//	Значение занимает 2 байта => использует 2 регистра.
		#define BMP180_ADDRR_AC6			0xB4 // 0xB4 - 0xB5					//	Значение занимает 2 байта => использует 2 регистра.
		#define BMP180_ADDRR_B1				0xB6 // 0xB6 - 0xB7					//	Значение занимает 2 байта => использует 2 регистра.
		#define BMP180_ADDRR_B2				0xB8 // 0xB8 - 0xB9					//	Значение занимает 2 байта => использует 2 регистра.
		#define BMP180_ADDRR_MB				0xBA // 0xBA - 0xBB					//	Значение занимает 2 байта => использует 2 регистра.
		#define BMP180_ADDRR_MC				0xBC // 0xBC - 0xBD					//	Значение занимает 2 байта => использует 2 регистра.
		#define BMP180_ADDRR_MD				0xBE // 0xBE - 0xBF					//	Значение занимает 2 байта => использует 2 регистра.
//		Адреса регистров общих для BMP датчиков:								//
		#define BMPXXX_ADDRR_ID				0xD0 // 0xD0						//	Регистр содержит идентификатор чипа
		#define BMPXXX_ADDRR_VERSION		0xD1 // 0xD1						//	Регистр содержит версию прошивки чипа
		#define BMPXXX_ADDRR_RESET			0xE0 // 0xE0						//	Регистр программной перезагрузки
		#define BMPXXX_ADDRR_CTRL			0xF4 // 0xF4						//	Регистр содердит флаги и биты управления
//		Адреса регистров хранящих результаты вычислений:						//
		#define BMP180_ADDRR_ALL			0xF6 // 0xF6 - 0xF8					//	Регистр данных давления и температуры чипа BMP180
		#define BMP280_ADDRR_PRES			0xF7 // 0xF7 - 0xF9					//	Регистр данных давления чипа BMP280
		#define BMP280_ADDRR_TEMP			0xFA // 0xFA - 0xFC					//	Регистр данных температуры чипа BMP280
//		Адреса регистров не использующихся в данной библиотеке:					//
		#define BMP280_ADDRR_CAL26			0xE1 // 0xE1 - 0xF0					//
		#define BMP280_ADDRR_CONF			0xF5 // 0xF5						//
																				//
class iarduino_Pressure_BMP{													//
	public:																		//
	/**	Конструктор класса **/													//
		iarduino_Pressure_BMP				(uint8_t i=0x77){objI2C = new iarduino_I2C; valAddress=i;}	//											(аргументы: адрес датчика на шине I2C)
	/**	пользовательские функции **/											//
		bool		begin					(float=0);							//	Объявляем  функцию инициализации датчика						(аргументы: текущая высота)
		bool		measurement				(uint8_t);							//	Объявляем  функцию установки точности							(аргументы: степень передискретизации - точность) // значение от 0-минимальная до 3 (для bmp180) или до 4 (для bmp280) включительно
		bool		read					(uint8_t=1);						//	Объявляем  функцию чтения всех данных сенсора					(аргументы: цифра 1 или 2) // 1 - получить давление в мм.рт.ст., 2 - получить давление в Па
	/**	пользовательские переменные **/											//
		float		temperature;												//	Объявляем  переменную для хранения температуры					(°C)
		float		pressure;													//	Объявляем  переменную для хранения давления						(мм.рт.ст. или Па)
		float		altitude;													//	Объявляем  переменную для хранения высоты	 					(м)
		int			type					= 0;								//	Определяем переменную для хранения типа датчика					(180 или 280)
		int			version					= 0;								//	Определяем переменную для хранения версии датчика				()
	private:																	//
	/**	внутренние функции **/													//
		uint32_t	readBytes				(uint8_t, uint8_t=1, bool=true);	//	Объявляем  функцию чтения регистров датчика в виде числа		(аргументы: адрес_регистра, количество_байт, чем_старше_регистр_тем_старше_байт)
	/**	внутренние переменные **/												//
		iarduino_I2C_BASE*	objI2C;												//	Объявляем указатель на объект полиморфного класса iarduino_I2C_BASE, но в конструкторе данного класса этому указателю будет присвоена ссылка на производный класс iarduino_I2C
		uint8_t		valAddress				= 0;								//	Определяем переменную для хранения адреса чипа на шине I2C		(0x77 для bmp180, или 0x76-0x77 для bmp280)
		uint8_t		valID					= 0;								//	Определяем переменную для хранения Id чипа						(0x55 для bmp180, или 0x58 для bmp280)
		uint8_t		valMeasurement			= 4;								//	Определяем переменную для хранения степени передискретизации	(от 0 до 3 или 4 включительно, в зависимости от датчика, bmp180 или bmp280)
		float		valSeaLevelPressure		= 0;								//	Определяем переменную для хранения давления на уровне моря		(мм.рт.ст.)
		int32_t		BMP_TEMP;													//	Объявляем  переменную для «сырого» значения температуры			(из регистров датчика)
		int32_t		BMP_PRES;													//	Объявляем  переменную для «сырого» значения давления			(из регистров датчика)
		uint16_t	BMP_16U[3];													//	Объявляем  массив для хранения калибровочных значений			(из регистров датчика)
		int16_t		BMP_16S[10];												//	Объявляем  массив для хранения калибровочных значений			(из регистров датчика)
		int32_t		BMP_32S[2];													//	Объявляем  массив для хранения промежуточных значений			(при выполнении расчётов)
		uint32_t	BMP_32U[2];													//	Объявляем  массив для хранения промежуточных значений			(при выполнении расчётов)
		int64_t		BMP_64S[3];													//	Объявляем  массив для хранения промежуточных значений			(при выполнении расчётов)
};																				//
																				//
#endif																			//